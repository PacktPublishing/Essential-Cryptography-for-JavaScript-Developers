// Import the axios module to make HTTP requests
// https://www.npmjs.com/package/axios
const axios = require('axios').default

// Import the required modules
const crypto = require('crypto')
const {promisify} = require('util')

// Promisify the crypto.generateKeyPair and crypto.randomBytes methods
const generateKeyPair = promisify(crypto.generateKeyPair)
const randomBytes = promisify(crypto.randomBytes)

// URL where the server is listening on
const serverUrl = 'http://localhost:3000'

// Need to wrap this in an immediately-invoked function expression (IIFE) because of async code
;(async function() {
    // Message to send encrypted
    const message = 'Hello world'

    // Begin the key agreement by requesting the server's public key
    let publicKeyRes = await axios.get(serverUrl + '/public-key')
    const serverKey = publicKeyRes.data

    // Generate a new x25519 key for this client
    // Then export the public key as PEM
    const clientKeyPair = await generateKeyPair('x25519')
    const clientPublicKeyPem = clientKeyPair.publicKey.export({
        type: 'spki',
        format: 'pem'
    })

    // Calculate the shared secret
    const sharedSecret = crypto.diffieHellman({
        publicKey: crypto.createPublicKey(serverKey.publicKey),
        privateKey: clientKeyPair.privateKey
    })

    // Because the shared secret generated by an ECDH function isn't uniformly random, we will need to stretch it to generate a 32-byte key (for AES-256-GCM), for example using SHA-256 with a random 16-byte salt as Key-Derivation Function (KDF)
    const salt = await randomBytes(16)
    const symmetricKey = crypto.createHash('sha256')
        .update(Buffer.concat([sharedSecret, salt]))
        .digest()

    // Encrypt the message using AES-256
    const encryptedMessage = await aesEncrypt(symmetricKey, message)

    // Submit the encrypted message, as well as our (the client's) public key to the server, so the server can decrypt it
    // We're not transmitting the symmetric encryption key or the shared secret; the server will generate those from our public key and its own private key
    await axios.post(serverUrl + '/message', {
        serverKeyId: serverKey.keyId,
        publicKey: clientPublicKeyPem,
        // Add the salt used for the KDF at the beginning then encode the message as base64
        message: Buffer.concat([salt, encryptedMessage]).toString('base64')
    })
})()

/** Example symmetric encryption function from aes-256-gcm */

async function aesEncrypt(key, plaintext) {
    const iv = await randomBytes(12)
    const cipher = crypto.createCipheriv('aes-256-gcm', key, iv)
    const encrypted = Buffer.concat([
        cipher.update(plaintext, 'utf8'),
        cipher.final()
    ])
    const tag = cipher.getAuthTag()
    return Buffer.concat([iv, tag, encrypted])
}
