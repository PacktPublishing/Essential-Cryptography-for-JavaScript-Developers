// Wrap in an asynchronous IIFE (Immediately-Invoked Function Expression) because we need to use the await keyword
;(async () => {
    // Message to encrypt, converted to a buffer
    const plaintextMessage = 'Hello world!'
    const encoder = new TextEncoder()
    const plaintext = encoder.encode(plaintextMessage)

    // Generate a key pair for Alice (using the P-256 curve)
    const aliceKeyPair = await newKeyPair()

    // Generate a key pair for Bob  (using the P-256 curve)
    const bobKeyPair = await newKeyPair()

    // Alice encrypts a message so it can be sent to Bob
    const encrypted = await AliceEncrypt(
        aliceKeyPair.privateKey,
        bobKeyPair.publicKey,
        plaintext
    )

    // Alice transmits to Bob her public key as well as the encrypted message
    // Bob decrypts that by computing the shared secret and then reverting the encryption
    const decrypted = await BobDecrypt(
        bobKeyPair.privateKey,
        aliceKeyPair.publicKey,
        encrypted
    )

    // Show the result, converted to string
    const decoder = new TextDecoder('utf-8')
    console.log('Decrypted message:',
        decoder.decode(decrypted)
    )
})()

/**
 * Alice uses this function to encrypt a message with an ECIES algorithm that uses:
 * 
 * - ECDH for key agreement with Bob, to generate a shared secret
 * - SHA-256 with a random salt to derive the symmetric encryption key, stretching the shared secret
 * - AES-256-GCM as authenticated symmetric cipher to encrypt the data
 * 
 * Returns the message that Alice needs to send to Bob, which includes the salt used for SHA-256, the ciphertext, and the AES-GCM authentication tag
 * 
 * @param {CryptoKey} alicePrivateKey Alice's private key
 * @param {CryptoKey} bobPublicKey Bob's public key
 * @param {ArrayBufferLike} plaintext The message to encrypt, as a buffer
 * @returns {Promise<Uint8Array>} Message that Alice needs to send to Bob
 */
 async function AliceEncrypt(alicePrivateKey, bobPublicKey, plaintext) {
    // Because the shared secret generated by an ECDH function isn't uniformly random, we will need to stretch it to generate a 32-byte key (for AES-256-GCM), for example using SHA-256 with a random 16-byte salt as Key-Derivation Function (KDF)
    // Here we're generating a random salt
    const salt = new Uint8Array(16)
    window.crypto.getRandomValues(salt)

    // Alice calculates the shared key using her own private key and Bob's public key
    // The derived key will be used with AES-GCM to encrypt/decrypt data
    const symmetricKey = await deriveSecretKey(
        alicePrivateKey,
        bobPublicKey,
        salt
    )

    // Encrypt the plaintext using the symmetric key
    const encrypted = await symmetricEncrypt(symmetricKey, plaintext)

    // Return the concatenation of the salt used for the KDF and the encrypted message (which contains the IV and the authentication tag too)
    return new Uint8Array([...salt, ...encrypted])
}

/**
 * Bob uses this function to decrypt the message he received from Alice.
 * 
 * This function calculates the shared secret using ECDH, with Bob's private key and Alice's public key. Then it uses the same ECIES algorithm as AliceEncrypt does to decrypt the data.
 * 
 * @param {CryptoKey} bobPrivateKey Bob's private key
 * @param {CryptoKey} alicePublicKey Alice's public key
 * @param {ArrayBufferLike} encryptedMessage Message Bob received from Alice, as a buffer
 * @returns {Promise<ArrayBufferLike>} Decrypted message (as a buffer)
 */
async function BobDecrypt(bobPrivateKey, alicePublicKey, encryptedMessage) {
    // The first 16 bytes of the encryptedMessage contain the salt for the KDF, which was used to stretch the sharedSecret into a symmetricKey
    const salt = encryptedMessage.slice(0, 16)

    // Bob calculates the shared secret using his own private key and Alice's public key
    // The derived key will be used with AES-GCM to encrypt/decrypt data
    const symmetricKey = await deriveSecretKey(
        bobPrivateKey,
        alicePublicKey,
        salt
    )

    // The remaining bytes (16-) of encryptedMessage are the message encrypted with AES-256-GCM (including the IV and authentication tag)
    // Decrypt that using the symmetric key
    const decrypted = await symmetricDecrypt(
        symmetricKey,
        encryptedMessage.slice(16)
    )

    // Return the decrypted message
    return decrypted
}

/**
 * Encrypts the plaintext message using the given key with AES-256-GCM
 * @param {CryptoKey} symmetricKey The 256-bit symmetric key that can be used to encrypt data with AES-GCM
 * @param {ArrayBufferLike} plaintext The message to encrypt, as a buffer
 * @returns {Promise<Uint8Array>} The result is the concatenation of the IV, the ciphertext, and the AES-GCM authentication tag
 */
async function symmetricEncrypt(symmetricKey, plaintext) {
    // Generate a random IV for AES-GCM (16 bytes)
    const iv = new Uint8Array(16)
    window.crypto.getRandomValues(iv)

    // Encrypt the plaintext using AES-256-GCM and the symmetric key
    // The result contains the AES-GCM authentication tag automatically appended at the end
    const encrypted = await window.crypto.subtle.encrypt(
        // Set the algorithm to AES-GCM and pass the IV
        {name: 'AES-GCM', iv: iv},
        // Symmetric key
        symmetricKey,
        // Message to encrypt
        plaintext
    )

    // Return the concatenation of the IV and the encrypted data (ciphertext)
    return new Uint8Array([
        ...iv,
        ...new Uint8Array(encrypted)
    ])
}

/**
 * Decrypts a message using the given key with AES-256-GCM
 * @param {CryptoKey} symmetricKey The 256-bit symmetric key that can be used to decrypt data with AES-GCM
 * @param {ArrayBufferLike} ciphertext A buffer containing the message to decrypt, which has the IV prepended and the AES-GCM authentication tag appended
 * @returns {Promise<ArrayBufferLike>} The decrypted message, as a buffer
 */
function symmetricDecrypt(symmetricKey, ciphertext) {
    // Extract the IV and the ciphertext from the ciphertext
    // The first 16 bytes are for the IV, the rest is for the ciphertext (which includes the authentication tag)
    const iv = ciphertext.slice(0, 16)
    const encrypted = ciphertext.slice(16)

    // Decrypt the message using AES-256-GCM and the symmetric key
    return window.crypto.subtle.decrypt(
        // Set the algorithm to AES-GCM and pass the IV
        {name: 'AES-GCM', iv: iv},
        // Symmetric key
        symmetricKey,
        // Ciphertext
        encrypted
    )
}

/**
 * Derive an AES-256-GCM key performing an ECDH key exchange.
 * This function is modified to use deriveBits to perform the ECDH exchange and then "stretch" the derived data with SHA-256 and a salt, to make it more uniform.
 * @param {CryptoKey} privateKey Private part of our own key
 * @param {CryptoKey} publicKey Public part of the other person's key
 * @param {ArrayBufferLike} salt Salt to be used during the key derivation
 * @returns {Promise<CryptoKey>} A new AES-256-GCM key in a CryptoKey object
 */
 async function deriveSecretKey(privateKey, publicKey, salt) {
    // First, derive a sequence of bytes (in an ArrayBuffer) by performing an ECDH exchange
    const ecdhResult = await window.crypto.subtle.deriveBits(
        {
            // Specify this is an ECDH exchange
            name: 'ECDH',
            // Use the other person's public key in "algorithm.public"
            public: publicKey
        },
        // Pass our private key as "baseKey"
        privateKey,
        // Request 256 bits (32 bytes) of data
        256
    )

    // Append the salt to the ECDH result
    const base = new Uint8Array(ecdhResult.byteLength + salt.byteLength)
    base.set(ecdhResult)
    base.set(salt, ecdhResult.byteLength)

    // Stretch the result of the ECDH exchange with the salt by calculating a SHA-256 hash
    const rawKey = await window.crypto.subtle.digest('SHA-256', base)

    // Create a CryptoKey object from the rawKey data, for use with AES-256-GCM
    return window.crypto.subtle.importKey(
        // Import the key in "raw" format
        'raw',
        // Key data
        rawKey,
        // Set the algorithm for the resulting key to AES-GCM
        {name: 'AES-GCM'},
        // Make the resulting key not extractable
        false,
        // Usages for the resulting key
        ['encrypt', 'decrypt']
    )
}

/**
 * Generate a new Elliptic Curve key pair, creating a new random P-256 key every time. The key can be used to perform ECDH key exchanges.
 * @returns {Promise<CryptoKeyPair>} Key pair object
 */
 function newKeyPair() {
    // Generate a new P-256 key pair for ECDH
    return window.crypto.subtle.generateKey(
        // Options for the algorithm to use
        {
            // Name of the algorithm: ECDH for a key exchange
            name: 'ECDH',
            // Name of the curve: P-256 is the same curve as prime256v1 in Node.js
            namedCurve: 'P-256'
        },
        // Key is non-extractable
        false,
        // Key can be used for deriving bits only
        ['deriveBits']
    )
}
